// Prisma Schema for Alveo System
// Multi-tenant architecture with row-level isolation

generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// ============================================================================
// SUBSCRIPTION & BILLING
// ============================================================================

model Plan {
  id          String   @id @default(cuid())
  name        String   @unique // free, basic, enterprise
  displayName String
  price       Decimal  @db.Decimal(10, 2) // Monthly price in USD
  
  // Limits
  maxAdmins   Int
  maxDoctors  Int
  maxPatients Int
  
  // Features (stored as JSON for flexibility)
  features    Json     @default("[]")
  
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  subscriptions Subscription[]

  @@map("plans")
}

model Subscription {
  id                   String             @id @default(cuid())
  tenantId             String
  planId               String
  status               SubscriptionStatus @default(ACTIVE)
  
  // dLocal integration
  dlocalCustomerId     String?
  dlocalCardId         String?            // Tokenized card for recurring
  
  // Billing period
  currentPeriodStart   DateTime
  currentPeriodEnd     DateTime
  cancelAtPeriodEnd    Boolean            @default(false)
  
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt

  tenant   Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  plan     Plan      @relation(fields: [planId], references: [id], onDelete: Restrict)
  payments Payment[]

  @@unique([tenantId])
  @@index([planId])
  @@index([status])
  @@index([dlocalCustomerId])
  @@map("subscriptions")
}

model Payment {
  id               String        @id @default(cuid())
  subscriptionId   String
  
  amount           Decimal       @db.Decimal(10, 2)
  currency         String        @db.Char(3) // Inherited from tenant settings
  status           PaymentStatus @default(PENDING)
  
  // dLocal fields
  dlocalPaymentId  String?       @unique
  dlocalOrderId    String?       @unique
  paymentMethod    String?       // CARD, BANK_TRANSFER, etc.
  
  // Metadata
  description      String?
  failureReason    String?
  paidAt           DateTime?
  
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt

  subscription Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@index([subscriptionId])
  @@index([status])
  @@index([createdAt])
  @@map("payments")
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
  REFUNDED
  CANCELLED
}

enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELED
  TRIALING
  PAUSED
}

// ============================================================================
// MULTI-TENANCY
// ============================================================================

model Tenant {
  id        String   @id @default(cuid())
  name      String   // Clinic name
  /// URL-friendly identifier. Must be validated at application level
  /// to contain only lowercase letters, numbers, and hyphens.
  slug      String   @unique
  
  // Contact info
  email     String?
  phone     String?
  address   String?  @db.Text
  
  // Branding
  logo      String?  // URL to logo
  /// IANA timezone identifier (e.g., "America/New_York", "Europe/London")
  timezone  String   @default("America/New_York")
  /// ISO 4217 currency code (e.g., USD, EUR, GBP)
  currency  String   @db.Char(3) @default("USD")
  
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  subscription  Subscription?
  settings      TenantSettings?
  users         User[]
  patients      Patient[]
  doctors       Doctor[]
  appointments  Appointment[]
  labworks      Labwork[]
  expenses      Expense[]

  @@index([slug])
  @@index([isActive])
  @@map("tenants")
}

model TenantSettings {
  id        String @id @default(cuid())
  tenantId  String @unique
  
  // Localization
  language      String @default("es") // ISO 639-1: es, en, pt
  dateFormat    String @default("DD/MM/YYYY") // DD/MM/YYYY, MM/DD/YYYY, YYYY-MM-DD
  timeFormat    String @default("24h") // 12h, 24h
  
  // Appointment defaults
  defaultAppointmentDuration Int @default(30) // minutes
  appointmentBuffer          Int @default(0)  // minutes between appointments
  
  // Business hours (JSON: { mon: { start: "09:00", end: "18:00" }, ... })
  businessHours Json @default("{}")
  
  // Working days (array of day numbers: 0=Sunday, 1=Monday, etc.)
  workingDays Json @default("[1,2,3,4,5]") // Mon-Fri by default
  
  // Notifications
  emailNotifications    Boolean @default(true)
  smsNotifications      Boolean @default(false)
  appointmentReminders  Boolean @default(true)
  reminderHoursBefore   Int     @default(24)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@map("tenant_settings")
}

// ============================================================================
// USERS & AUTHENTICATION
// ============================================================================

model User {
  id             String    @id @default(cuid())
  /// Nullable for SUPER_ADMIN users who don't belong to any tenant
  tenantId       String?
  
  /// Email address. Must be validated at application level for format.
  email          String
  /// Hashed password using bcrypt/argon2. NEVER expose in API responses.
  /// When querying users, always exclude this field from selections.
  passwordHash   String    @db.VarChar(255)
  
  firstName      String
  lastName       String
  role           UserRole  @default(STAFF)
  
  // Profile
  avatar         String?   // URL to avatar
  phone          String?
  
  // Auth
  emailVerified  Boolean   @default(false)
  lastLoginAt    DateTime?
  
  isActive       Boolean   @default(true)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  tenant              Tenant?              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  refreshTokens       RefreshToken[]
  passwordResetTokens PasswordResetToken[]

  @@unique([tenantId, email]) // Email unique per tenant (nulls are distinct)
  @@index([tenantId])
  @@index([email])
  @@index([role])
  @@index([tenantId, role])
  @@index([isActive])
  @@map("users")
}

// ============================================================================
// PATIENTS
// ============================================================================

model Patient {
  id         String   @id @default(cuid())
  tenantId   String

  firstName  String
  lastName   String
  email      String?  
  phone      String?
  dob        DateTime?
  gender     String?  @db.VarChar(20)
  address    String?  @db.Text
  notes      Json?
  
  /// Dental chart notes per tooth (ISO 3950 notation)
  /// Format: { "11": "Crown needed", "21": "Caries", ... }
  teeth      Json?

  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  appointments Appointment[]
  labworks     Labwork[]

  @@index([tenantId])
  @@index([lastName])
  @@unique([tenantId, email])
  @@map("patients")
}

// ============================================================================
// DOCTORS
// ============================================================================

model Doctor {
  id             String   @id @default(cuid())
  tenantId       String

  firstName      String
  lastName       String
  email          String?
  phone          String?
  
  /// Medical specialty (e.g., "General Dentistry", "Orthodontics")
  specialty      String?
  /// Professional license number
  licenseNumber  String?
  
  /// Working days as JSON array (e.g., ["MON", "TUE", "WED"])
  workingDays    Json     @default("[]")
  /// Working hours as JSON (e.g., {"start": "09:00", "end": "18:00"})
  workingHours   Json?
  
  /// Consultation room or office number
  consultingRoom String?
  
  /// Profile photo URL
  avatar         String?
  /// Bio or professional summary
  bio            String?  @db.Text
  
  /// Hourly rate for billing purposes
  hourlyRate     Decimal? @db.Decimal(10, 2)

  isActive       Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  appointments Appointment[]

  @@index([tenantId])
  @@index([lastName])
  @@unique([tenantId, email])
  @@unique([tenantId, licenseNumber])
  @@map("doctors")
}

// ============================================================================
// APPOINTMENTS
// ============================================================================

model Appointment {
  id          String            @id @default(cuid())
  tenantId    String
  patientId   String
  doctorId    String

  /// Appointment start date and time (stored in UTC)
  startTime   DateTime
  /// Appointment end date and time (stored in UTC)
  endTime     DateTime
  /// Duration in minutes (derived from start/end, stored for convenience)
  duration    Int               @default(30)

  status      AppointmentStatus @default(SCHEDULED)
  
  /// Type of appointment (e.g., "Checkup", "Cleaning", "Root Canal")
  type        String?
  /// Treatment or procedure notes
  notes       String?           @db.Text
  /// Private notes (not visible to patient)
  privateNotes String?          @db.Text
  
  /// Cost of the appointment
  cost        Decimal?          @db.Decimal(10, 2)
  /// Whether payment has been received
  isPaid      Boolean           @default(false)

  isActive    Boolean           @default(true)
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  patient     Patient  @relation(fields: [patientId], references: [id], onDelete: Cascade)
  doctor      Doctor   @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([patientId])
  @@index([doctorId])
  @@index([startTime])
  @@index([status])
  @@index([tenantId, startTime])
  @@index([doctorId, startTime])
  @@map("appointments")
}

enum AppointmentStatus {
  SCHEDULED    // Confirmed appointment
  CONFIRMED    // Patient confirmed attendance
  IN_PROGRESS  // Currently happening
  COMPLETED    // Successfully finished
  CANCELLED    // Cancelled by patient or clinic
  NO_SHOW      // Patient didn't show up
  RESCHEDULED  // Moved to another time
}

enum UserRole {
  SUPER_ADMIN // Platform super administrator, no tenant
  OWNER       // Tenant owner, full access
  ADMIN       // Administrative access
  DOCTOR      // Can manage patients and appointments
  STAFF       // Limited access
}

// ============================================================================
// LABWORKS (Laboratory Work Orders)
// ============================================================================

model Labwork {
  id          String   @id @default(cuid())
  tenantId    String
  
  /// Optional reference to the patient this labwork is for
  patientId   String?
  
  /// Name of the laboratory
  lab         String
  /// Contact phone for the laboratory
  phoneNumber String?
  
  /// Date the labwork was ordered/due
  date        DateTime
  
  /// Description or notes about the work
  note        String?  @db.Text
  
  /// Cost of the labwork
  price       Decimal  @db.Decimal(10, 2) @default(0)
  /// Whether payment has been made
  isPaid      Boolean  @default(false)
  /// Whether the labwork has been delivered
  isDelivered Boolean  @default(false)
  
  /// IDs of doctors associated with this labwork (stored as JSON array)
  doctorIds   Json     @default("[]")

  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  tenant  Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  patient Patient? @relation(fields: [patientId], references: [id], onDelete: SetNull)

  @@index([tenantId])
  @@index([patientId])
  @@index([date])
  @@index([isPaid])
  @@index([isDelivered])
  @@map("labworks")
}

// ============================================================================
// EXPENSES (Clinic Expenses and Receipts)
// ============================================================================

model Expense {
  id          String   @id @default(cuid())
  tenantId    String
  
  /// Date of the expense
  date        DateTime
  
  /// Amount of the expense
  amount      Decimal  @db.Decimal(10, 2) @default(0)
  
  /// Who issued the receipt/invoice
  issuer      String?
  /// Contact phone number
  phoneNumber String?
  
  /// Description or notes
  note        String?  @db.Text
  
  /// List of items in this expense (stored as JSON array)
  items       Json     @default("[]")
  
  /// Tags for categorization (stored as JSON array)
  tags        Json     @default("[]")
  
  /// Whether the expense has been paid
  isPaid      Boolean  @default(false)
  
  /// IDs of doctors/staff associated with this expense (stored as JSON array)
  doctorIds   Json     @default("[]")

  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([date])
  @@index([isPaid])
  @@map("expenses")
}

model RefreshToken {
  id        String   @id @default(cuid())
  userId    String
  /// Stores a securely hashed refresh token, not the raw token.
  /// Hash the token before storing and compare hashes on validation.
  tokenHash String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

model PasswordResetToken {
  id        String    @id @default(cuid())
  userId    String
  /// SHA-256 hash of the reset token. Never store plain tokens.
  tokenHash String    @unique
  expiresAt DateTime
  /// Timestamp when the token was used. Null if unused.
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@map("password_reset_tokens")
}
